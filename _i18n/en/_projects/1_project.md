## Motivation
A few years ago, a lattice structure generator was developed in the [Rhinoceros](https://en.wikipedia.org/wiki/Rhinoceros_3D "Rhinoceros 3D") environmental application (__[Figure 1](#caption1)__). This generator could model several types of lattices along certain path types in both Cartesian and polar coordinate systems. The goal of this project was to reconstruct the mentioned generator based on Object-Oriented Programming (OOP) and simultaneously implement it as a library for [NX](https://en.wikipedia.org/wiki/Siemens_NX "Siemens NX")-Open.
<br>
<br>
<br>
<div class="image-270dg-grid-caption-wrapper">
<div class="row ">
    <div class="col-sm mt-3 mt-md-0 img-magnifier-container" id="caption1">
        {% include figure.liquid path="assets/img/myProj1/motivation.png" title="Lozenge lattice" id= "Lozenge lattice"
        class="img-fluid rounded z-depth-1 mx-auto d-block magnify" alt="Lozenge diagram" scale=2 %}
    </div>
</div>
<div class="caption">
    Figure 1: <a href="https://en.wikipedia.org/wiki/Rhombus">Lozenge</a> lattice with the path y = ax² + b with b = 0 (Hover over to magnify
    <tr>
      <td>
        <i class="fa-solid fa-magnifying-glass-plus iconmagnifyPlus" aria-hidden="true"></i>
      </td>
      <td class="building">)</td>
    </tr>
</div>
</div>
<br>
<br>
>
The following section discusses the software development process for the problem described above. Additionally, an overview of the tools used and challenges encountered during the process is provided.

## Tools Used
The project was implemented with the programming language ***C# 6***, extended by some open-source packages and libraries such as ***Net.Core*** for project creation, ***Math.NET*** for application in Linear Algebra, *[Protobuf](https://protobuf.dev/)*  for data serialization, and ***NX-Open-Utilities*** for application of available interfaces regarding a geometric utility (see also _[Design](#design)_). ***Visual Studio*** 2017 was used as the development environment. Version control and automatic generation of developer documentation were carried out on the general ***GitLab*** of [RWTH](https://www.rwth-aachen.de/go/id/a/?lidx=1). For software modeling was used *[Enterprise Architect](https://en.wikipedia.org/wiki/Enterprise_Architect_(software))* 13.4 .


## Design
In terms of requirement analysis for functions of the future library and code analysis from the already written non-OOP, the following features emerge:
- Ability to extrude, rotate, and revolve of a lattice
- Ability to restrict the edges of a lattice in connection with geometric and mechanical properties

The entire design of the class structure (__[Figure 2](#caption2 "Class diagram for Gitter-Struktur-Generator")__) was carried out only after a rough design of flowcharts and was conceived like the <a href="https://refactoring.guru/design-patterns/adapter">adapter</a> pattern insofar as interfaces compatible with *NX-Open*  in our project should be used for the visualization of the lattice (__[Figure 3](#caption3)__). Since changes to the adapter class should not affect the overall architecture (*Principle of Loose Coupling* (PLC)), the module was created in another package.

<br>
<div class="image-270dg-grid-caption-wrapper">
<div class="row ">
    <div class="col-sm mt-3 mt-md-0 img-magnifier-container" id="caption2">
        {% include figure.liquid path="assets/img/myProj1/latticeGenerator_klassnendiagramm.png" title="latticeGenerator" id= "latticeGenerator"
        class="img-fluid rounded z-depth-1 mx-auto d-block magnify" alt="latticeGenerator" scale= 3.5 %}
    </div>
</div>
<div class="caption">
    Figure 2: Class diagramm for the Lattice Structure Generator (Hover over to magnify
    <tr>
      <td>
        <i class="fa-solid fa-magnifying-glass-plus iconmagnifyPlus" aria-hidden="true"></i>
      </td>
      <td class="building">)</td>
    </tr>
</div>
</div>
<br>

## Implementation
First, the implementation of the interface and base class is determined, which play the following role:
- ***ILatticeInterface*** describes the interface to an abstract visualization method. This consists of a method with a lattice automatically generated by Protobuf as an output parameter.
- ***Path*** has the necessary method for building a path, on whose coordinates lattice points (eng Lattice Group) are started or oriented.

<a id="word-to-refer"></a>
Subsequently, with the help of the above abstractions and the ***IDGenerator*** in the ***LayerGenerator*** class, the layers are first created, in which lattice points are stored indexed depending on the cross-section types for the build space of the lattice in a dictionary. Consequently, the method "*GenerateStruts()*" of <sub style="font-size: 1.02em;">__[∨](#code-snippets "StrutGenerator Class")__</sub>***StrutGenerator***
for creating the edges between lattice points is instantiated. In both classes, ***LatticeParameter*** provides physical and geometric properties of a lattice, which in turn are checked in ***BuildRestrectionChecker*** for the production of the entire lattice before concrete methods<sup style="font-size: 0.85em;">**[Ʌ](#design "Abilities")**</sup> for the lattice generator can be carried out in ***LatticeGenerator***. For the procedure "*revolve()*", ***Axis*** is used, which
 describes the rotations of any point around an axis[^M05].  


[^M05]: Marsh, Duncan (2005). Applied Geometry for Computer Graphics and CAD (2nd ed.). Springer Undergraduate Mathematics Series. pp 45-52. [978-1-85233-801-5](https://link.springer.com/book/10.1007/b138823).

Finally, to test the mentioned procedures, different test methods regarding the lattice types are programmed and tested based on ***NXOpenLatticeAdapter***. Both common (under the method "*validateLattice()*") and specific assertions are introduced in random and explicit lattice spaces. The mentioned helper class contains several methods for visualizing the lattice within the *NX-Open*  sessions as part of our incremental software development process, especially to prevent collisions of edges between each unique pair.


## Extensibility
Due to the application of a conical section, several paths can be reconstructed under ***CircularPath*** (__[Figure 4](#caption4)__). Therefore, by converting them to a well-defined superclass, many lattice models can be inserted, especially in the method *„Revolve( )“* (__[Figure 5](#caption5)__)in the Model package. In addition, expansion of a polynomial combined path in the package is possible and in general, our software product allows for expansion with other software adapters due to the fulfillment of the PLC.

<br>
<div class="row justify-content-sm-center align-items-end">
    <div class="col-sm-5 mt-3 mt-md-0 d-flex flex-column" id="caption3">
        {% include figure.liquid path="assets/img/myProj1/adapter_class_daigrame.png" title="adapter class" id="adapter class" 
            class="img-fluid rounded z-depth-1" scale=1.5 %}
        <div class="caption">Figure 3: Adapter Class to Visualization <br> (Hover over to magnify
         <tr>
           <td style="vertical-align: top; text-align: center" >
             <i class="fa-sharp fa-solid fa-magnifying-glass-plus iconmagnifyPlus" aria-hidden="true"></i>
           </td>
           <td class="building">)</td>
         </tr>
        </div>
    </div>
    <div class="col-sm-7 mt-3 mt-md-0 d-flex flex-lg-column" id="caption4">
        {% include figure.liquid path="assets/img/myProj1/pathModel_class_daigrame.png" title="Basic Path Model"  id="Basic Path Model" class="img-fluid rounded z-depth-1" scale=1.75 %}
        <div class="caption">Figure 4: Class diagrams to current path model <br> (Hover over to magnify
         <tr>
           <td style="vertical-align: top; text-align: center" >
             <i class="fa-sharp fa-solid fa-magnifying-glass-plus iconmagnifyPlus" aria-hidden="true"></i>
           </td>
           <td class="building">)</td>
         </tr>
        </div>
    </div>
</div>


## Code Snippets
<sup style="font-size: 0.85em;">[Ʌ](#word-to-refer "StrutGenerator") </sup>The first code section illustrates parts of the general base edge state or their neighbor relationship for lattice points. To reduce the data field (the attributes) of the class, an application of construction structure is covered by enumeration ***BaseSide*** (no *BaseSide Right*, ..., *BaseSide Left*).
{% highlight c# linenos %}
class StrutGenerator
{
    internal struct BaseStrut
    {
        internal uint startIndex;
        internal uint endIndex;
        internal HashSet<BaseSide> side;
        internal BaseStrut(uint startIndex, uint endIndex, BaseSide side)
        {
            this.startIndex = startIndex;
            this.endIndex = endIndex;
            this.side = new HashSet<BaseSide> {side };
        }
    }
    //The neighbour relationships
    internal enum BaseSide
    {
        RIGHT,
        LEFT,
        TOP,
        BOTTOM,
        BACK,
        FRONT,
        INTERMEDIATE
    }
    // number of vetrtices per row and rows for each layer
    private uint _nrOrow;
    private uint _nrOvert;
    private List<BaseStrut> baseStruts;
    private LatticeParameters _latticeParameters;
    //the constructor for struts
    public StrutGenerator(List<BaseStrut> baseStruts)
    {
        this.baseStruts = baseStruts ?? throw new ArgumentNullException(nameof(baseStruts));
    }
    public StrutGenerator(LatticeParameters parameter, uint nrOrow, uint nrOvert)
    {
        _latticeParameters = parameter;
        _nrOrow = nrOrow;
        _nrOvert = nrOvert;
        baseStruts = new List<BaseStrut>();
        var newStrut = new BaseStrut();
        switch (parameter.structureType)
        {
            case StructureType.LOZENGE:
            // in-plane left/right
                baseStruts.Add(new BaseStrut(1, 7, BaseSide.BACK));
                baseStruts.Add(new BaseStrut(3, 5, BaseSide.BACK));
                baseStruts.Add(new BaseStrut(0, 6, BaseSide.BACK));
                baseStruts.Add(new BaseStrut(2, 4, BaseSide.BACK));
                break;
            case StructureType.RIGHT_SIDED:
                // vertical in-plane right
                newStrut = new BaseStrut(0, 2, BaseSide.FRONT);
                newStrut.side.Add(BaseSide.LEFT);
                baseStruts.Add(newStrut);
                baseStruts.Add(new BaseStrut(0, 3, BaseSide.FRONT));
             ⋮
             ⋮
        }  
    } 
}
{% endhighlight %}
<br>
In the following code segment, the test method for certain lattice generators is illustrated.

{% highlight c# linenos %}
[TestMethod]
// Test of an extrusion for parallel Lozenge
public void TestExtrudeParallelLozengeRand()
{
    var rect = new Rectangle((float)rand.NextDouble() * 10 + 1, (float)rand.NextDouble() * 10 + 1);
    parameter.latticeType = LatticeType.PARALLEL_PLANES;
    parameter.interPlaneStructure = InterPlaneStructure.REINFORCED;
    parameter.structureType = StructureType.LOZENGE;
    parameter.density = new System.Numerics.Vector3(1, 1, 1);
    parameter.latticeDiameter = 0.2f;
    var lattice = generator.Extrude(rect, (float) rand.NextDouble() * 10, parameter);
    ValidateLattice(lattice);
    NXOpenAdapter.NXOpenLatticeAdapter.SaveLatticeAsCones(lattice, PathLocation.partFileName);
    var nL = lattice.Layers.Count;
    var nR = lattice.Layers[0].Rows.Count;
    var nV = lattice.Layers[0].Rows[0].Vertices.Count;
    Assert.AreEqual( 2*(nR - 1) * ((2*nV - 1)* nL - nV), lattice.Struts.Count, "");
}
{% endhighlight %}
<br>
## Result
The result of the project is currently an application library for the CAD software NX with further extension requirement, which concerns mechanical and geometric aspects[^aspect]. Indeed, it is able to construct lattices on different paths, including circular paths as demonstrated below. This showcases the library’s ability to adapt to a variety of geometric configurations, further enhancing its versatility in mechanical design.

[^aspect]: Specifically, a restriction concerns static values of a strut or entire struts such as at least normal and shear force and bending moment for a buildable lattice-structured object, which of course require geometric operations.
<br>
<br>
<div class="row justify-content-sm-center align-items-end">
    <div class="col-sm-6 mt-3 mt-md-0 d-flex flex-column">
        {% include figure.liquid path="assets/img/myProj1/2d_revolve_4pa.png" title="2d_revolve_4pa" 
            class="img-fluid rounded z-depth-1" scale=1.5 %}
    </div>
    <div class="col-sm-6 mt-3 mt-md-0 d-flex flex-lg-column">
        {% include figure.liquid path="assets/img/myProj1/3d_revolve_2.png" title="3d_revolve_2" class="img-fluid rounded z-depth-1" scale=1.75 %}
    </div>
</div>
<div class="row justify-content-sm-center align-items-end">
    <div class="col-sm-6 mt-3 mt-md-0 d-flex flex-column" id="caption5">
        {% include figure.liquid path="assets/img/myProj1/3d_revolve_3.png" title="3d_revolve_3" 
            class="img-fluid rounded z-depth-1" scale=1.5 %}
    </div>
    <div class="col-sm-6 mt-3 mt-md-0 d-flex flex-lg-column">
        {% include figure.liquid path="assets/img/myProj1/3d_revolve_4_1.png" title="3d_revolve_4" class="img-fluid rounded z-depth-1" scale=1.75 %}
    </div>
</div>
<div class="caption">
   Figure 5: Demonstration of the „revolve( )“ method under <span style="font-weight: bold;">CircularPath</span>
</div>
<br>
<br>

****


